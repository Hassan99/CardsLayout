//
//  CardsCollectionViewLayout.swift
//  CardsExample
//
//  Created by Filipp Fediakov on 18.08.17.
//  Copyright Â© 2017 filletofish. All rights reserved.
//

import UIKit

open class CardsCollectionViewLayoutSwipeEnabled: UICollectionViewLayout {

  // MARK: - Layout configuration

  public var itemSize: CGSize = CGSize(width: 300, height: 550) {
    didSet{
      invalidateLayout()
    }
  }

  public var spacing: CGFloat = 30.0 {
    didSet{
      invalidateLayout()
    }
  }

  public var maximumVisibleItems: Int = 5 {
    didSet{
      invalidateLayout()
    }
  }

  // MARK: UICollectionViewLayout

  override open var collectionView: UICollectionView {
    return super.collectionView!
  }

  override open var collectionViewContentSize: CGSize {
    let itemsCount = CGFloat(collectionView.numberOfItems(inSection: 0))
    let width = collectionView.bounds.width
    let height = collectionView.bounds.height
    return CGSize(width: width * itemsCount,//2n calling getting the collectionview height and width
                  height: height)
  }

  override open func prepare() {
    super.prepare()// first calling the prepare
    assert(collectionView.numberOfSections == 1, "Multiple sections aren't supported!")
  }

  override open func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
    let totalItemsCount = collectionView.numberOfItems(inSection: 0)  // third call and flows down,getting number of items in collectionview

    let xvalue = Int(collectionView.contentOffset.x) //get the x value of x, here 0
    let width = Int(collectionView.bounds.width)//get width of the collectionview here 414
    print(xvalue)
    let minVisibleIndex = max(xvalue / width, 0)// showing the minimum visible index, here 0
    let maxVisibleIndex = min(minVisibleIndex + maximumVisibleItems, totalItemsCount) // showing maximum visible index, here 5

    let contentCenterX =  collectionView.contentOffset.x + (collectionView.bounds.width / 2.0)// swipe left to clear all views

    let deltaOffset = Int(collectionView.contentOffset.x) % Int(collectionView.bounds.width)// x position of first view

    let percentageDeltaOffset = CGFloat(deltaOffset) / collectionView.bounds.width

    let visibleIndices = stride(from: minVisibleIndex, to: maxVisibleIndex, by:1)

    let attributes: [UICollectionViewLayoutAttributes] = visibleIndices.map
    { index in
      let indexPath = IndexPath(item: index, section: 0)
      return computeLayoutAttributesForItem(indexPath: indexPath,minVisibleIndex: minVisibleIndex,contentCenterX: contentCenterX,deltaOffset: CGFloat(deltaOffset),percentageDeltaOffset: percentageDeltaOffset)
    }

    return attributes
  }

  override open func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
    let contentCenterX = collectionView.contentOffset.x + (collectionView.bounds.width / 2.0)
    let minVisibleIndex = Int(collectionView.contentOffset.x) / Int(collectionView.bounds.width)
    let deltaOffset = Int(collectionView.contentOffset.x) % Int(collectionView.bounds.width)
    let percentageDeltaOffset = CGFloat(deltaOffset) / collectionView.bounds.width
    return computeLayoutAttributesForItem(indexPath: indexPath,
                                   minVisibleIndex: minVisibleIndex,
                                   contentCenterX: contentCenterX,
                                   deltaOffset: CGFloat(deltaOffset),
                                   percentageDeltaOffset: percentageDeltaOffset)
  }

  override open func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool {
    return true
  }
    public func moveToPage(position:Int){
        let totalPage = collectionView.contentOffset.x/collectionView.frame.width// getting totalNumberOfPage
        if position < Int(totalPage){
            scrollToPage(page: position, animated: true)
        }
    }
    public  func moveToNextPage()->Int{
            let pageIndex = round(collectionView.contentOffset.x/collectionView.frame.width)
            let pageNo = Int(pageIndex+1)
            scrollToPage(page: pageNo, animated: true)
            return pageNo
    }
    public  func moveToPreviousPage()->Int{
            let pageIndex = round(collectionView.contentOffset.x/collectionView.frame.width)
            let pageNo = Int(pageIndex-1)
            scrollToPage(page: pageNo, animated: true)
            return pageNo
    }
           
        
    func scrollToPage(page: Int, animated: Bool) {
        var frame: CGRect = self.collectionView.frame
        frame.origin.x = frame.size.width * CGFloat(page)
        frame.origin.y = 0
        self.collectionView.scrollRectToVisible(frame, animated: animated)
    }
        
   
}


// MARK: - Layout computations

 extension CardsCollectionViewLayoutSwipeEnabled {

  private func scale(at index: Int) -> CGFloat {
    let translatedCoefficient = CGFloat(index) - CGFloat(self.maximumVisibleItems) / 2
    return CGFloat(pow(0.95, translatedCoefficient))
  }

  private func transform(atCurrentVisibleIndex visibleIndex: Int, percentageOffset: CGFloat) -> CGAffineTransform {
    var rawScale = visibleIndex < maximumVisibleItems ? scale(at: visibleIndex) : 1.0

    if visibleIndex != 0 {
      let previousScale = scale(at: visibleIndex - 1)
      let delta = (previousScale - rawScale) * percentageOffset
      rawScale += delta
    }
    return CGAffineTransform(scaleX: rawScale, y: rawScale)
  }

   func computeLayoutAttributesForItem(indexPath: IndexPath,
                                       minVisibleIndex: Int,
                                       contentCenterX: CGFloat,
                                       deltaOffset: CGFloat,
                                       percentageDeltaOffset: CGFloat) -> UICollectionViewLayoutAttributes {
    let attributes = UICollectionViewLayoutAttributes(forCellWith:indexPath)
    let visibleIndex = indexPath.row - minVisibleIndex
    attributes.size = itemSize
    let midY = self.collectionView.bounds.midY
  
    attributes.center = CGPoint(x: contentCenterX + 0 * CGFloat(visibleIndex),
                                y: midY + spacing * CGFloat(visibleIndex))
  
    attributes.zIndex = maximumVisibleItems - visibleIndex

    attributes.transform = transform(atCurrentVisibleIndex: visibleIndex,
                                          percentageOffset: percentageDeltaOffset)
    switch visibleIndex {
    case 0:
      attributes.center.x -= deltaOffset
      break
    case 1..<maximumVisibleItems:
      attributes.center.x -= 0 * percentageDeltaOffset
      attributes.center.y -= spacing * percentageDeltaOffset


      if visibleIndex == maximumVisibleItems - 1 {
        attributes.alpha = percentageDeltaOffset
      }
      break
    default:
      attributes.alpha = 0
      break
    }
    return attributes
  }
    
    
   
    
}
